[{"path":"https://liamirwin.github.io/lidRtools/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 lidRtools authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://liamirwin.github.io/lidRtools/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Liam Irwin. Author, maintainer.","code":""},{"path":"https://liamirwin.github.io/lidRtools/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Irwin L (2025). lidRtools: Package (One Line, Title Case). R package version 0.0.0.9000, https://github.com/liamirwin/lidRtools.","code":"@Manual{,   title = {lidRtools: What the Package Does (One Line, Title Case)},   author = {Liam Irwin},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://github.com/liamirwin/lidRtools}, }"},{"path":"https://liamirwin.github.io/lidRtools/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"What the Package Does (One Line, Title Case)","text":"can install development version lidRtools directly GitHub using:","code":"devtools::install_github(\"liamirwin/lidRtools\")"},{"path":"https://liamirwin.github.io/lidRtools/reference/clip_square_interactive.html","id":null,"dir":"Reference","previous_headings":"","what":"Interactive Square ROI Clipping with lidR — clip_square_interactive","title":"Interactive Square ROI Clipping with lidR — clip_square_interactive","text":"Interactively clips square ROI LAS dataset. first builds canopy height model displays . user clicks centre square. square polygon constructed used clip LAS dataset.","code":""},{"path":"https://liamirwin.github.io/lidRtools/reference/clip_square_interactive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interactive Square ROI Clipping with lidR — clip_square_interactive","text":"","code":"clip_square_interactive(   las,   width = 100,   res = 1,   subcircle = 0,   return_type = c(\"las\", \"both\", \"polygon\") )"},{"path":"https://liamirwin.github.io/lidRtools/reference/clip_square_interactive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interactive Square ROI Clipping with lidR — clip_square_interactive","text":"las character string (path LAS/LAZ) LAS object. width Numeric. Side length square ROI (units CRS). Default: 100. res Numeric. Resolution (units) rasterizing CHM. Default: 1. subcircle Numeric. p2r subcircle canopy rasterization. Default: 0. return_type Character. return: \"las\" (default), \"\", \"polygon\". \"las\": return clipped LAS object (original behavior) \"polygon\": return square ROI sf polygon (sfc POLYGON) \"\": return named list list(las = <LAS>, roi = <sfc POLYGON>)","code":""},{"path":"https://liamirwin.github.io/lidRtools/reference/clip_square_interactive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interactive Square ROI Clipping with lidR — clip_square_interactive","text":"Depending return_type: \"las\": LAS object containing points within square ROI \"polygon\": sf sfc POLYGON selected ROI \"\": named list elements las roi","code":""},{"path":"https://liamirwin.github.io/lidRtools/reference/clip_square_interactive.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interactive Square ROI Clipping with lidR — clip_square_interactive","text":"","code":"if (FALSE) { # \\dontrun{   # Example using the Megaplot dataset   lasFile <- system.file(\"extdata\", \"Megaplot.laz\", package = \"lidR\")    las_clip <- clip_square_interactive(     las       = lasFile,     width     = 15,     res       = 1,     subcircle = 0.1,     return_type = \"las\"   ) } # }"},{"path":"https://liamirwin.github.io/lidRtools/reference/clip_transect_interactive.html","id":null,"dir":"Reference","previous_headings":"","what":"Interactive Transect Clipping with lidR — clip_transect_interactive","title":"Interactive Transect Clipping with lidR — clip_transect_interactive","text":"function interactively clips transect LAS dataset. first generates surface model (either Canopy Height Model Digital Terrain Model) displays . user prompted click two points (start end transect) plot. transect polygon constructed points used clip LAS dataset.","code":""},{"path":"https://liamirwin.github.io/lidRtools/reference/clip_transect_interactive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interactive Transect Clipping with lidR — clip_transect_interactive","text":"","code":"clip_transect_interactive(   las,   width = 5,   res = 1,   subcircle = 0,   plot_dtm = FALSE )"},{"path":"https://liamirwin.github.io/lidRtools/reference/clip_transect_interactive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interactive Transect Clipping with lidR — clip_transect_interactive","text":"las character string specifying path LAS/LAZ file LAS object. width Numeric. width transect. Default 5. res Numeric. resolution rasterizing surface model. Default 1. subcircle Numeric. Parameter p2r function used canopy rasterization (CHM ). Default 0. plot_dtm Logical. TRUE, generates plots Digital Terrain Model (DTM) using rasterize_terrain transect selection. FALSE (default), Canopy Height Model (CHM) used. Note: DTM generation requires classified ground points best results.","code":""},{"path":"https://liamirwin.github.io/lidRtools/reference/clip_transect_interactive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interactive Transect Clipping with lidR — clip_transect_interactive","text":"LAS object corresponding clipped transect.","code":""},{"path":"https://liamirwin.github.io/lidRtools/reference/clip_transect_interactive.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interactive Transect Clipping with lidR — clip_transect_interactive","text":"","code":"if (FALSE) { # \\dontrun{   # use the Megaplot example dataset from lidR:   lasFile <- system.file(\"extdata\", \"Megaplot.laz\", package = \"lidR\")    # Example 1: Interactive clipping using the default CHM   las_clipped_chm <- clip_transect_interactive(       las       = lasFile,       width     = 5,       res       = 1,       subcircle = 0.25     )    # Example 2: Interactive clipping using a DTM   # First, we need to read the LAS file and classify ground points   las <- readLAS(lasFile)   las <- classify_ground(las, algorithm = csf())    las_clipped_dtm <- clip_transect_interactive(       las       = las,       width     = 10,       res       = 1,       plot_dtm  = TRUE     ) } # }"},{"path":"https://liamirwin.github.io/lidRtools/reference/process_point_cloud.html","id":null,"dir":"Reference","previous_headings":"","what":"Process a LiDAR Point Cloud with Optional Transect Extraction — process_point_cloud","title":"Process a LiDAR Point Cloud with Optional Transect Extraction — process_point_cloud","text":"function provides complete workflow processing LAS/LAZ file. can perform decimation, interactive automated transect extraction, height normalization, tree segmentation. key feature ability define transect area clip original (unnormalized) fully processed point cloud.","code":""},{"path":"https://liamirwin.github.io/lidRtools/reference/process_point_cloud.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process a LiDAR Point Cloud with Optional Transect Extraction — process_point_cloud","text":"","code":"process_point_cloud(   las_file,   normalize = TRUE,   perform_treeID = FALSE,   decimation = FALSE,   extract_transect = TRUE,   cs_width = 1,   offset_x = 15,   odir = NULL,   oname = NULL )"},{"path":"https://liamirwin.github.io/lidRtools/reference/process_point_cloud.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process a LiDAR Point Cloud with Optional Transect Extraction — process_point_cloud","text":"las_file character string specifying path LAS/LAZ file. normalize Logical. TRUE, point cloud height-normalized using TIN-based DTM. Ground classification present best results. Default TRUE. perform_treeID Logical. TRUE, performs tree segmentation using lidR::silva2016 merges treeID point cloud. Default FALSE. decimation Logical. TRUE, decimates point cloud resolution one point per 0.5m voxel. Default FALSE. extract_transect Logical. TRUE, user prompted interactively draw transect DTM plot. FALSE, transect automatically created center point cloud. Default TRUE. cs_width Numeric. width transect units LAS data. Default 1. offset_x Numeric. extract_transect = FALSE, value specifies start point's X-offset minimum X coordinate. Default 15. odir Character string. path output directory processed files saved. NULL, files written. Default NULL. oname Character string. base name output files. NULL, \"output\" used. Default NULL.","code":""},{"path":"https://liamirwin.github.io/lidRtools/reference/process_point_cloud.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process a LiDAR Point Cloud with Optional Transect Extraction — process_point_cloud","text":"list containing three LAS objects: processed_cloud: full point cloud processing steps. processed_transect: transect clipped fully processed cloud. unnormalized_transect: transect clipped cloud normalization, retaining original Z values including initial classifications (hence _class suffix saved).","code":""},{"path":"https://liamirwin.github.io/lidRtools/reference/process_point_cloud.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Process a LiDAR Point Cloud with Optional Transect Extraction — process_point_cloud","text":"","code":"if (FALSE) { # \\dontrun{ # Get the path to the example LAS file from lidR las_file_in <- system.file(\"extdata\", \"Megaplot.laz\", package = \"lidR\")  results <- process_point_cloud(   las_file           = las_file_in,   extract_transect   = FALSE, # Run automatically   perform_treeID     = TRUE  # Skip tree identification )  # The results are a list of LAS objects. We can plot them. # Plot the final, processed transect (heights are normalized) plot(results$processed_transect)  # To run interactively instead, simply use the default: # results_interactive <- process_point_cloud(las_file = las_file_in) } # }"},{"path":"https://liamirwin.github.io/lidRtools/reference/tile_raster.html","id":null,"dir":"Reference","previous_headings":"","what":"Tile a Raster into a Grid of Polygons — tile_raster","title":"Tile a Raster into a Grid of Polygons — tile_raster","text":"function creates grid square hexagonal polygons extent source raster. iterates grid cell, cropping masking source raster create individual raster tiles.","code":""},{"path":"https://liamirwin.github.io/lidRtools/reference/tile_raster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tile a Raster into a Grid of Polygons — tile_raster","text":"","code":"tile_raster(   raster_layer,   grid_area,   grid_shape,   out_dir = NULL,   plot_grid = FALSE,   prompt_user = TRUE,   acceptable_coverage = 0.5,   write_grid = TRUE )"},{"path":"https://liamirwin.github.io/lidRtools/reference/tile_raster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tile a Raster into a Grid of Polygons — tile_raster","text":"raster_layer SpatRaster object terra package tiled. grid_area Numeric. target area grid cell square meters raster's CRS. grid_shape Character. shape grid cells. Must either \"square\" \"hexagon\". out_dir Character. Optional path directory output raster tiles grid geopackage saved. NULL, files written. plot_grid Logical. TRUE, displays plot generated grid overlaid raster review processing. prompt_user Logical. TRUE plot_grid TRUE, function pause ask user confirmation proceeding tile raster. acceptable_coverage Numeric. value 0 1 representing minimum proportional overlap grid cell must raster's extent processed. Defaults 0.5 (50%). write_grid Logical. TRUE out_dir specified, grid polygons saved geopackage output directory.","code":""},{"path":"https://liamirwin.github.io/lidRtools/reference/tile_raster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tile a Raster into a Grid of Polygons — tile_raster","text":"list containing two elements: raster_tiles named list SpatRaster objects, element tiled portion input raster. names list elements correspond unique grid_id cell. grid sf object containing grid polygons used tiling.","code":""},{"path":"https://liamirwin.github.io/lidRtools/reference/tile_raster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tile a Raster into a Grid of Polygons — tile_raster","text":"","code":"if (FALSE) { # \\dontrun{ if (requireNamespace(\"lidR\", quietly = TRUE)) {    # Create and tile a 1m CHM from the Megaplot.laz  output <- system.file(\"extdata\", \"Megaplot.laz\", package = \"lidR\") %>%    lidR::readLAS() %>%    lidR::rasterize_canopy(res = 1, algorithm = lidR::p2r(subcircle = 0.25)) %>%    tile_raster(      grid_area   = 900,         # 30x30m tiles      grid_shape  = \"square\",      acceptable_coverage = 0.95,      out_dir     = NULL,        # Don't write files to disk      plot_grid   = FALSE,       # Don't show a plot      write_grid  = FALSE,      prompt_user = FALSE    )    # Check the raster output (a list of SpatRasters)   print(output$raster_tiles[[1]])    # Check the grid polygon output   print(head(output$grid)) } } # }"}]
